DEMO1) Call db.schema()2)  Most themes per year match (s:Set)-[:HAS_THEME]-(t:Theme) return s.year as year, t.name as theme, count(t.name) as frequency order by year desc, frequency desc3) Top 3 Themes per yearmatch (s:Set)-[:HAS_THEME]-(t:Theme) with s.year as year, t.name as theme, count(t.name) as frequency order by year desc, frequency desc return year, collect(theme)[0..3] as listofthemesHighlight the fact that themes based on friends and entertainment world like Star wars, batman have taken over the basic sets, city etc.4) Visualization on Set, Theme, Information, FeaturesMATCH (Set)-[:HAS_THEME]-(Theme), (Set)-[:has_details]-(information),(Set)-[:has_features]-(features)      RETURN *5)  Analyzing themes with Avg Rating and Avg PriceMATCH (Set)-[:HAS_THEME]-(Theme),(Set) -[:has_features]- (features) where Theme.name in ['Star Wars','Batman','Basic Set','Ninjago','Friends','Duplo','Easter','Technic']                   with Theme.name as theme, avg(toint(features.price)) as avgprice order by Theme.name                      MATCH (Set)-[:HAS_THEME]-(Theme),(Set) -[:has_details]- (information)   where Theme.name in ['Star Wars','Batman','Basic Set','Ninjago','Friends','Duplo','Easter','Technic']               with theme, avgprice, Theme.name as themetwo, avg(toint(information.star_rating)) as avgrating order by themetwo where theme=themetwo return theme, avgprice, avgrating order by avgrating descShow that themes like Basic Set, City have received better ratings than Friends, Batman etc.6)  Sets based on friends theme with ratings from customersMATCH (Set)-[:HAS_THEME]-(Theme{name:'Friends'}), (Set)-[:has_details]-(information)                       RETURN Set.name as Setname, Theme.name as Themename, avg(toint(information.star_rating)) as averagerating order by averagerating descShow how marketing efforts could be ignited more on best reviewed sets like heartlake puppy7)  Sets based on star wars and analyze prop like price and ratingMATCH (Set)-[:HAS_THEME]-(Theme{name:'Star Wars'}), (Set)-[:has_details]-(information) , (Set)-[:has_features]-(features)                                                                           RETURN Set.name as Setname, Theme.name as Themename, avg(toint(information.star_rating)) as averagerating, avg(toint(features.price)) as averageprice order by averagerating descShow how sets which are rated similarly, a higher priced set should be a priority since too many sets per theme are being produced8) Number of distinct colors used per themeMATCH (Color) < - [:HAS_COLOR]-(InventoryPart)-[:ASSOCIATED_INVENTORY]->(Inventory)-[:INVENTORY_FOR]->(Set)-[:HAS_THEME]-(Theme)                      RETURN Theme.name as theme, count(distinct Color.name) as distinctcolors order by distinctcolors descShow how this question can be answered without requiring to perform 4 joins from theme to the color table and just use in-built relationships to extract the required info9) Themes followed with the list of colors used in the sets related to that theme ordered by the frequencyMATCH (Color) < - [:HAS_COLOR]-(InventoryPart)-[:ASSOCIATED_INVENTORY]->(Inventory)-[:INVENTORY_FOR]->(Set)-[:HAS_THEME]-(Theme)                      WITH Theme.name as theme, Color.name as color, count(*) as usage order by theme, usage desc                                                              RETURN theme, collect(color) as listofcolors order by size(listofcolors) desc10)  Show top 5 colors used per themeMATCH (Color) < - [:HAS_COLOR]-(InventoryPart)-[:ASSOCIATED_INVENTORY]->(Inventory)-[:INVENTORY_FOR]->(Set)-[:HAS_THEME]-(Theme)                      WITH Theme.name as theme, Color.name as color, count(*) as usage order by theme, usage desc               WHERE theme in ['Basic Set','Supplemental','Classic Town','Batman','Ben 10','Star Wars','Friends']                                               Return theme, collect(color)[0..5] as top5colorsusedShow how sets of themes like batman, friends etc which have been recently more popular are focused on light bluish gray and dark bluish gray but themes like basic sets, supplemental were more based on just primary colors11) Interesting obs hereMATCH (Color) < - [:HAS_COLOR]-(InventoryPart)-[:ASSOCIATED_INVENTORY]->(Inventory)-[:INVENTORY_FOR]->(Set)-[:HAS_THEME]-(Theme)                      WITH Theme.name as theme, Color.name as color, count(*) as usage order by theme, usage desc                                                              With theme, collect(color)[0..5] as top5colorsused                            RETURN top5colorsused, count(*) as occurence order by occurence descInteresting to note that Red white black light bluish gray and dark bluish gray are the 5 colors with max occurrence together as a group12) Recommending sets based on the same theme mentality (for puppy pampering)MATCH (s:Set{name:'Puppy Pampering'})-[:HAS_THEME]->(t:Theme)<-[:HAS_THEME]-(rec:Set)                             RETURN rec 23 sets also belonging to the same theme as Puppy pampering (seems relevant but not diverse) 13) Adding diversity to same theme mentality (puppy pampering)MATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s1:Set{name:'Puppy Pampering'}) with s1.name as setone, toint(pc.id) as PCone, count(*)  as occurenceone  order by occurenceone desc        with setone, collect(PCone) as partcategoriesMATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s2:Set)-[:HAS_THEME]-(t:Theme) where t.name ='Animals'With setone,partcategories, s2.name as setname, toint(pc.id) as PCtwo, count(*) as occurencetwo order by occurencetwo descWith setone,partcategories, setname, collect(PCtwo) as partcattwowith setone, setname, algo.similarity.jaccard(partcategories, partcattwo) AS similarityinpartcats order by similarityinpartcats descreturn *14) Hierarchy of themes in consideration when building a recommendation systemMATCH (S:Set{name:'Puppy Pampering'})                                          MATCH path=(S)-[*1..2]- > (t:Theme) < - [*1..2] - (rec:Set)                  Return *Another way to recommend sets is to check out themes which are connected to each other or hierarchical in nature. The concept here is that if a person buys a desk which is from office supply category which might be connected to furniture category so we can recommend products from furniture category to the person and not just restricted to office supplies.  15)  Filtering results of above hierarchy based on those sets which received above 4 star ratingMATCH (S:Set{name:'Puppy Pampering'})                                          MATCH path=(S)-[*1..2]- > (t:Theme) < - [*1..2] - (rec:Set) -[:has_details] ->(i:information)  WHERE tofloat(i.star_rating) > 4.0       RETURN * order by i.star_rating descHere we are able to select the best potential recommendations out of those 200 plus possibilities 16)  Louvain (community detection for themes) MATCH (t:Theme) WHERE EXISTS(t.louvain) RETURN DISTINCT t.name as theme, t.louvain AS louvain LIMIT 25 UNION ALL MATCH ()-[r]-() WHERE EXISTS(r.louvain) RETURN DISTINCT "relationship" AS theme, r.louvain AS louvain LIMIT 2517) Visualization in Graph XR (SETS AND THEMES WITH SUPERHEROES COMMUNITY)MATCH (Set)- [:HAS_THEME]->(T:Theme) WHERE T.name in 	["Super Heroes", "Batman", "Guardians of the Galaxy", "Ultimate Collector Series", "Justice League", "Avengers", "Spider-Man", "Superman", "Iron Man", "X-Men"] return *18) Louvain Neuler Visualization Node color-Louvain, Node Size- Degree (Bionicle highest degree node imp) - Page Rank (Town (connectivity /influence)// Similarity in Part Categories for sets in Friends theme (Diversity in same theme recommendations)MATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s1:Set{name:'Heartlake Party Shop'}) with s1.name as setone, toint(pc.id) as PCone, count(*)  as occurenceone  order by occurenceone desc        with setone, collect(PCone) as partcategoriesMATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s2:Set)-[:HAS_THEME]-(t:Theme) where t.name ='Friends'With setone,partcategories, s2.name as setname, toint(pc.id) as PCtwo, count(*) as occurencetwo order by occurencetwo descWith setone,partcategories, setname, collect(PCtwo) as partcattwowith setone, setname, algo.similarity.jaccard(partcategories, partcattwo) AS similarityinpartcats order by similarityinpartcats descwith setname, setone, similarityinpartcats                                    MATCH (Set)-[:has_details]-(information), (Set) -[:HAS_THEME]-(Theme)       where Theme.name ='Friends' and Set.name=setname                             return setname, setone, similarityinpartcats, Set.name as set, avg(tofloat(information.star_rating)) as avgrating order by similarityinpartcats desc
// 1) Visualization of Set, Features and InformationMATCH (Set)-[:has_details]-(information), (Set)-[:has_features]-(features)    RETURN Set, information, features// 2) Recommending sets based on the same theme mentality (for puppy pampering)MATCH (s:Set{name:'Puppy Pampering'})-[:HAS_THEME]->(t:Theme)<-[:HAS_THEME]-(rec:Set)                             RETURN rec// Finding communities of themes in this network of sets and themes and parent themes// 3) Using Louvain with node idCALL algo.louvain.stream("Theme", "HAS_PARENT_THEME", {})YIELD nodeId, community // 4) Theme name along with community MATCH (t:Theme) WHERE EXISTS(t.louvain) RETURN DISTINCT t.name as entity, t.louvain AS louvain LIMIT 25 UNION ALL MATCH ()-[r]-() WHERE EXISTS(r.louvain) RETURN DISTINCT "relationship" AS entity, r.louvain AS louvain LIMIT 25// Helps us identify hierarchy of themes by grouping them in communities// 5)  Find all themes and order them by community and PageRank scoresMATCH (t:Theme)WITH tORDER BY t.louvain, t.pagerank DESC// Return top 10 ranked themes grouped by communityWITH  t.louvain AS community, collect(t.name) AS themesRETURN community, themes[..10], size(themes) as sizeofcommunityORDER BY size(themes) DESC// 6)  Hierarchy of themes in consideration when building a recommendation systemMATCH (S:Set{name:'Puppy Pampering'})                                          MATCH path=(S)-[*1..2]- > (t:Theme) < - [*1..2] - (rec:Set)                  Return *// All potential recommendations to Puppy Pampering set based on hierarchy of themes // 7) Finding Jaccard Similarity between two themes based on the distinct colors used in the themesMATCH (Color) < - [:HAS_COLOR]-(InventoryPart)-[:ASSOCIATED_INVENTORY]->(Inventory)-[:INVENTORY_FOR]->(Set)-[:HAS_THEME]-(t1:Theme)                     WHERE t1.name='Batman'                                         with t1, collect(distinct(toint(Color.id))) as listofcolorsone                    MATCH (Color) < - [:HAS_COLOR]-(InventoryPart)-[:ASSOCIATED_INVENTORY]->(Inventory)-[:INVENTORY_FOR]->(Set)-[:HAS_THEME]-(t2:Theme)                     WHERE t2.name='Friends'                                                  with t1,listofcolorsone,t2, collect(distinct(toint(Color.id))) as listofcolorstwo                                                              RETURN algo.similarity.jaccard(         listofcolorsone, listofcolorstwo) AS score// 8) Finding Jaccard Similarity between two sets based on the distinct colors used in the setsMATCH (Color) < - [:HAS_COLOR]-(InventoryPart)-[:ASSOCIATED_INVENTORY]->(Inventory)-[:INVENTORY_FOR]->(s1:Set)                  WHERE s1.name='Puppy Pampering'                                         with s1, collect(distinct(toint(Color.id))) as listofcolorsone                    MATCH (Color) < - [:HAS_COLOR]-(InventoryPart)-[:ASSOCIATED_INVENTORY]->(Inventory)-[:INVENTORY_FOR]->(s2:Set)                     WHERE s2.name='Puppy Playground'                                                 with s1,listofcolorsone,s2, collect(distinct(toint(Color.id))) as listofcolorstwo       RETURN algo.similarity.jaccard( listofcolorsone, listofcolorstwo) AS score// 9) Finding stats on Similar themes in terms of similarity scoresMATCH (Color) < - [:HAS_COLOR]-(InventoryPart)-[:ASSOCIATED_INVENTORY]->(Inventory)-[:INVENTORY_FOR]->(Set)-[:HAS_THEME]-(t1:Theme)                  WITH {item: id(t1), categories: collect(distinct(id(Color))) } as setdatawith collect(setdata) as data                                                CALL algo.similarity.jaccard(data, {write: false})YIELD nodes, similarityPairs, min, max, mean,       p25, p50, p75, p99, p999, p100RETURN nodes, similarityPairs, min, max, mean,        p25, p50, p75, p99, p999, p100// 10) Finding similar themes in terms of the colors they constitute (for all the nodes of themes)(using algo.similarity.jaccard.stream)MATCH (Color) < - [:HAS_COLOR]-(InventoryPart)-[:ASSOCIATED_INVENTORY]->(Inventory)-[:INVENTORY_FOR]->(Set)-[:HAS_THEME]-(t1:Theme)                  WITH { item: id(t1), categories: collect(distinct(id(Color))) } as setdatawith collect(setdata) as dataCALL algo.similarity.jaccard.stream(data)YIELD item1, item2, count1, count2, intersection, similarityWITH algo.asNode(item1) AS Theme1,      algo.asNode(item2) AS Theme2,      similarity, intersection RETURN Theme1.name, Theme2.name, intersection, similarityORDER BY similarity DESC// 11) Finding similar themes by averaging the similarities to get a similarity coeffMATCH (Color) < - [:HAS_COLOR]-(InventoryPart)-[:ASSOCIATED_INVENTORY]->(Inventory)-[:INVENTORY_FOR]->(Set)-[:HAS_THEME]-(t1:Theme)                  WITH { item: id(t1), categories: collect(distinct(id(Color))) } as setdatawith collect(setdata) as dataCALL algo.similarity.jaccard.stream(data)YIELD item1, item2, count1, count2, intersection, similarity// Look up nodes by node idWITH algo.asNode(item1) AS Theme1,      algo.asNode(item2) AS Theme2,      similarity, intersection with Theme1.name as Theme1, Theme2.name as Theme2, intersection, similarityORDER BY similarity DESC                                                      return Theme1,Theme2,avg(similarity) as similaritycoeff order by similaritycoeff desc// 12) Overall Avg Similarity coeff MATCH (Color) < - [:HAS_COLOR]-(InventoryPart)-[:ASSOCIATED_INVENTORY]->(Inventory)-[:INVENTORY_FOR]->(Set)-[:HAS_THEME]-(t1:Theme)                  WITH { item: id(t1), categories: collect(distinct(id(Color))) } as setdatawith collect(setdata) as dataCALL algo.similarity.jaccard.stream(data)YIELD item1, item2, count1, count2, intersection, similarity// Look up nodes by node idWITH algo.asNode(item1) AS Theme1,      algo.asNode(item2) AS Theme2,      similarity, intersection with Theme1.name as Theme1, Theme2.name as Theme2, intersection, similarityORDER BY similarity DESC                                                      with Theme1,Theme2,avg(similarity) as similaritycoeff order by similaritycoeff desc return avg(similaritycoeff)// comes out to be 0.32// 13) Writing Relationship to the graph database (optional, can just mention write as false to view and not save) (also option to filter using similarity cutoff or topk)MATCH (Color) < - [:HAS_COLOR]-(InventoryPart)-[:ASSOCIATED_INVENTORY]->(Inventory)-[:INVENTORY_FOR]->(Set)-[:HAS_THEME]-(t1:Theme)                  WITH { item: id(t1), categories: collect(distinct(id(Color))) } as setdatawith collect(setdata) as dataCALL algo.similarity.jaccard.stream(data, {write: true,writeRelationshipType: "SIMILAR", writeProperty: "score",similarityCutoff: 0.7})YIELD nodes, similarityPairs, min, max, mean, p25, p50, p75, p99, p999, p100RETURN nodes, similarityPairs, min, max, mean, p25, p50, p75, p99, p999, p100// 14) Collecting all the difficulty levels of each theme in a list (also label encoding the levels)MATCH (Set)-[:has_details]-(i:information), (Set)-[:HAS_THEME]-(t1:Theme)Where t1.name='Friends'withSet.name as setname,t1.id as themeid,t1.name as themename, CASE i.review_difficultyWHEN 'Very Easy'THEN 1WHEN 'Easy'THEN 2WHEN 'Average'THEN 3WHEN 'Challenging'THEN 4ELSE 5 END AS resultone With themename, collect(resultone) as reviewfirstMATCH (Set)-[:has_details]-(i:information), (Set)-[:HAS_THEME]-(t1:Theme)Where t1.name='Animals'with themename, reviewfirst,Set.name as setnametwo,t1.id as themeidtwo,t1.name as themenametwo, CASE i.review_difficultyWHEN 'Very Easy'THEN 1WHEN 'Easy'THEN 2WHEN 'Average'THEN 3WHEN 'Challenging'THEN 4ELSE 5 END AS resulttworeturn themename,reviewfirst,themenametwo, collect(resulttwo) as reviewsecond// 15) Similarity score between two themes (Angry Birds and Architecture) based on their difficulty levelsMATCH (Set)-[:has_details]-(i:information), (Set)-[:HAS_THEME]-(t1:Theme)Where t1.name='Angry Birds'withSet.name as setname,t1.id as themeid,t1.name as themename, CASE i.review_difficultyWHEN 'Very Easy'THEN 1WHEN 'Easy'THEN 2WHEN 'Average'THEN 3WHEN 'Basic Set'THEN 4ELSE 5 END AS resultone With themename, collect(resultone) as reviewfirstMATCH (Set)-[:has_details]-(i:information), (Set)-[:HAS_THEME]-(t1:Theme)Where t1.name='Architecture'with themename, reviewfirst,Set.name as setnametwo,t1.id as themeidtwo,t1.name as themenametwo, CASE i.review_difficultyWHEN 'Very Easy'THEN 1WHEN 'Easy'THEN 2WHEN 'Average'THEN 3WHEN 'Challenging'THEN 4ELSE 5 END AS resulttwowith themename,reviewfirst,themenametwo, collect(resulttwo) as reviewsecond                                                               RETURN algo.similarity.jaccard(reviewfirst,reviewsecond) AS similarityscore// 16) Frequency of part categories for each theme (panel form)MATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s:Set)-[:HAS_THEME]-(t1:Theme)  Return t1.name as Themename, pc.name as PartCategory, count(*) as frequency order by Themename, frequency desc // 17) Listing partcategories for 2 themes (friends and animals here) MATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s:Set)-[:HAS_THEME]-(t1:Theme)                 where t1.name= 'Friends' with t1.name as themeone, toint(pc.id) as PartCategoryIdone, count(*)  as occurenceone  order by occurenceone desc                 with themeone, collect(PartCategoryIdone) as listofpartcategoryoneMATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s:Set)-[:HAS_THEME]-(t1:Theme)where t1.name= 'Animals' with themeone, listofpartcategoryone, t1.name as themetwo, toint(pc.id) as PartCategoryIdtwo, count(*)  as occurencetwo  order by occurencetwo desc return themeone, listofpartcategoryone, themetwo, collect(PartCategoryIdtwo) as listofpartcategorytwo// 18) Similarity Score between two themes (Friends and Animals) based on part categories they containMATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s:Set)-[:HAS_THEME]-(t1:Theme)                 where t1.name= 'Friends' with t1.name as themeone, toint(pc.id) as PCone, count(*)  as occurenceone  order by occurenceone desc                 with themeone, collect(PCone) as listofPConeMATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s:Set)-[:HAS_THEME]-(t1:Theme)where t1.name= 'Animals' with themeone, listofPCone, t1.name as themetwo, toint(pc.id) as PCtwo, count(*)  as occurencetwo  order by occurencetwo desc with themeone, listofPCone, themetwo, collect(PCtwo) as listofPCtwoRETURN algo.similarity.jaccard( listofPCone, listofPCtwo) AS similarityscore             // 19) Stats of similarity scores of themes based on part categoriesMATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s:Set)-[:HAS_THEME]-(t1:Theme)                 with t1, toint(pc.id) as PCone, count(*)  as occurenceone  order by occurenceone descwith {item: id(t1), categories: collect(PCone)} as themedatawith collect(themedata) as dataCALL algo.similarity.jaccard(data, {write: false})YIELD nodes, similarityPairs, min, max, mean,       p25, p50, p75, p99, p999, p100RETURN nodes, similarityPairs, min, max, mean,        p25, p50, p75, p99, p999, p100// 20) Similarity between 2 sets (Puppy Pampering and Heartlake puppy daycare) in terms of part categories they constituteMATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s1:Set) where s1.name= 'Puppy Pampering' with s1.name as setone, toint(pc.id) as PartCategoryIdone, count(*)  as occurenceone  order by occurenceone desc                 with setone, collect(PartCategoryIdone) as listofpartcategoryoneMATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s1:Set)where s1.name= 'Heartlake Puppy Daycare' with setone, listofpartcategoryone, s1.name as settwo, toint(pc.id) as PartCategoryIdtwo, count(*)  as occurencetwo  order by occurencetwo desc with setone, listofpartcategoryone, settwo, collect(PartCategoryIdtwo) as listofpartcategorytwoReturn algo.similarity.jaccard( listofpartcategoryone, listofpartcategorytwo) AS similarityscore// 21) Recom (Final) Filtering out recommendations with < 0.60 similarity in parts and > 4-star rating MATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s1:Set{name:'Puppy Playground'}) with s1.name as Comparing, toint(pc.id) as PCone, count(*)  as occurenceone  order by occurenceone desc        with Comparing, collect(PCone) as partcategoriesMATCH (pc:PartCategory)< -[:HAS_PART_CATEGORY]-(p:Part)< -[:FOR_PART]-(ip:InventoryPart)-[:ASSOCIATED_INVENTORY]-(inv:Inventory)-[:INVENTORY_FOR]- > (s2:Set)-[:HAS_THEME]-(t:Theme) where t.name in ['Friends','Animals','Jungle Rescue']With Comparing,partcategories, s2.name as Setname, toint(pc.id) as PCtwo, count(*) as occurencetwo order by occurencetwo descWith Comparing,partcategories, Setname, collect(PCtwo) as partcattwowith Comparing, Setname, algo.similarity.jaccard(partcategories, partcattwo) AS PartsSimilarity order by PartsSimilarity descwith Setname, Comparing, PartsSimilarity                                MATCH (Set)-[:has_details]-(information), (Set) -[:HAS_THEME]-(Theme)       where Theme.name in['Friends','Animals','Jungle Rescue'] and Set.name=Setname                                                         with Comparing,Setname, PartsSimilarity, Set.name as set, avg(tofloat(information.star_rating)) as avgrating order by PartsSimilarity desc                                                                     with Comparing, Setname, PartsSimilarity, avgrating order by PartsSimilarity , avgrating desc                                                             where PartsSimilarity <= 0.60 and avgrating > 4.0                           return *                                          